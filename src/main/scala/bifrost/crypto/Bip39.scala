package bifrost.crypto

import scorex.crypto.hash.Sha256
import scala.io.Source
import scala.math.BigInt
import java.io.File
import java.nio.file.Files
import java.security.{DigestInputStream, MessageDigest}

/*
 * AMS Feb 2019:
 * Phrase translator class for translating given seed phrases
 * and UUID strings generated by java.util.UUID.randomUUID.toString
 *
 * Mnemonic seed phrase standard is given by the
 * Bitcoin Improvement Project 39 (BIP39) specification:
 * https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
 *
 * Expected input phrase length is 12 words corresponding to 128 bit UUID
 * and implementation corresponds to 128 bits of entropy
 *
 * Phrase list directory given by:
 * https://github.com/bitcoin/bips/tree/master/bip-0039
 */

class Bip39 (phraseLanguage: String) {

  /*
   * Calculates the MD5 checksum of an entire directory recursively, taken from:
   * http://www.michaelpollmeier.com/2018/12/10/checksum-files-scala
   */
  def md5(roots: File*): String = {
    val md = MessageDigest.getInstance("MD5")
    roots.foreach { root =>
      Files.walk(root.toPath).filter(!_.toFile.isDirectory).forEach { path =>
        val dis = new DigestInputStream(Files.newInputStream(path), md)
        // fully consume the inputstream
        while (dis.available > 0) {
          dis.read
        }
        dis.close
      }
    }
    md.digest.map(b => String.format("%02x", Byte.box(b))).mkString
  }

  val phraseListDir = "src/main/resources/bip-0039/"
  val phraseListMD5 = md5(new File(phraseListDir))
  val preMD5 = "3d7914c7810cb343a5db65548cb5d66a"
  val wordList = Source.fromFile(phraseListDir + phraseLanguage).getLines.toList

  def verify: Unit = {
    if (preMD5 != phraseListMD5) throw new Exception("BIP39 phrase list directory didn't pass checksum")
  }

  def toBinaryIndex(i: Int): String = String.format("%11s", BigInt(i).toString(2) ).replace(' ', '0')

  def toBinaryByte(b: Byte): String = String.format("%8s", BigInt(b & 0xff).toString(2) ).replace(' ', '0')

  def hexToUuid(s: String) : String = s.slice(0,8)+"-"+s.slice(8,12)+"-"+s.slice(12,16)+"-"+s.slice(16,20)+"-"+s.substring(20)

  def phraseToHex(phrase: String): String = {
    val phraseWords: Array[String] = phrase.split(" ")
    val wordChk: Boolean = phraseWords.map(wordList.contains(_)).foldLeft(true)(_ && _) && phraseWords.length == 12
    if (!wordChk) throw new Exception("Seed phrase doesn't adhere to BIP39")
    val phraseIndex: Array[Int] = phraseWords.map(wordList.indexOf(_))
    val phraseBin = phraseIndex.map(toBinaryIndex(_)).mkString
    val phraseBytes: Array[Byte] = phraseBin.slice(0,128).grouped(8).toArray map {Integer.parseInt(_, 2).toByte}
    val chksum = phraseBin.substring(128)
    val phraseHash: Array[Byte] = Sha256.hash(phraseBytes)
    val phraseHashBin: Array[String] = phraseHash.map(toBinaryByte(_))
    if (chksum != phraseHashBin(0).slice(0,4)) throw new Exception("Seed phrase doesn't pass checksum")
    val phraseHex = phraseBytes.map("%02x" format _).mkString
    return phraseHex
  }

  def seedPhrase(inputUuid: String): (String,String) = {
    val toRemove = "-".toSet
    val seed = inputUuid.filterNot(toRemove)
    val seedBytes: Array[Byte] = seed.grouped(2).toArray map {Integer.parseInt(_, 16).toByte}
    val seedHash: Array[Byte] = Sha256.hash(seedBytes)
    val seedBin: Array[String] = seedBytes.map(toBinaryByte(_))
    val seedHashBin: Array[String] = seedHash.map(toBinaryByte(_))
    val chksum = seedHashBin(0).slice(0,4)
    val seedPhraseBin = seedBin.mkString("") + chksum
    val phraseBin: Array[String] = seedPhraseBin.grouped(11).toArray
    val phrase = phraseBin.map(Integer.parseInt(_,2)).map(wordList(_)).mkString(" ")
    return (seed,phrase)
  }
}
