package co.topl.modifier.block

import co.topl.attestation.EvidenceProducer.Syntax._
import co.topl.attestation.{PrivateKeyCurve25519, PublicKeyPropositionCurve25519, SignatureCurve25519}
import co.topl.modifier.NodeViewModifier.ModifierTypeId
import co.topl.modifier.block.Block._
import co.topl.modifier.transaction.Transaction
import co.topl.modifier.{ModifierId, NodeViewModifier}
import co.topl.nodeView.state.box.ArbitBox
import io.circe.syntax._
import io.circe.{Decoder, Encoder, HCursor}
import scorex.crypto.hash.Blake2b256
import supertagged.@@

/**
 * A block is an atomic piece of data network participates are agreed on.
 *
 * A block has:
 * - transactional data: a sequence of transactions, where a transaction is an atomic state update.
 * Some metadata is possible as well(transactions Merkle tree root, state Merkle tree root etc).
 *
 * - consensus data to check whether block was generated by a right party in a right way. E.g.
 * "baseTarget" & "generatorSignature" fields in the Nxt block structure, nonce & difficulty in the
 * Bitcoin block structure.
 *
 * - a signature(s) of a block generator(s)
 *
 * - additional data: block structure version no, timestamp etc
 */
case class Block( parentId    : BlockId,
                  timestamp   : Timestamp,
                  forgerBox   : ArbitBox,
                  publicKey   : PublicKeyPropositionCurve25519,
                  signature   : SignatureCurve25519,
                  transactions: Seq[Transaction.TX],
                  version     : Version
                ) extends TransactionCarryingPersistentNodeViewModifier[Transaction.TX] {

  lazy val modifierTypeId: ModifierTypeId = Block.modifierTypeId

  lazy val id: BlockId = ModifierId(Blake2b256(messageToSign))

  lazy val messageToSign: Array[Byte] = this.copy(signature = SignatureCurve25519.empty).bytes

  def toComponents: (BlockHeader, BlockBody) = Block.toComponents(this)

  override def toString: String = Block.jsonEncoder(this).noSpaces
}

object Block {

  type BlockId = ModifierId
  type Timestamp = Long
  type Version = Byte

  val blockIdLength: Int = NodeViewModifier.ModifierIdSize
  val modifierTypeId: Byte @@ NodeViewModifier.ModifierTypeId.Tag = ModifierTypeId @@ (3: Byte)
  val signatureLength: Int = SignatureCurve25519.SignatureSize

  def toComponents(block: Block): (BlockHeader, BlockBody) = {
    val header: BlockHeader =
      BlockHeader(
        block.id,
        block.parentId,
        block.timestamp,
        block.forgerBox,
        block.publicKey,
        block.signature,
        block.merkleTree.rootHash,
        block.bloomFilter,
        block.version
      )

    val body: BlockBody = BlockBody(block.id, block.parentId, block.transactions)

    (header, body)
  }

  /**
   * Creates a full block from the individual components
   * @param header the header information needed by the consensus layer
   * @param body the block body containing transactions
   * @return a full block
   */
  def fromComponents(header: BlockHeader, body: BlockBody): Block = {
    val (_, parentId, timestamp, forgerBox, publicKey, signature, _, _, version) = BlockHeader.unapply(header).get
    val transactions = body.transactions

    Block(parentId, timestamp, forgerBox, publicKey, signature, transactions, version)
  }

  /**
   *
   * @param parentId
   * @param timestamp
   * @param txs
   * @param box
   * @param privateKey
   * @param version
   * @return
   */
  def create ( parentId  : BlockId,
               timestamp : Timestamp,
               txs       : Seq[Transaction.TX],
               box       : ArbitBox,
               privateKey: PrivateKeyCurve25519,
               version   : Version
             ): Block = {

    // the owner of the generator box must be the key used to sign the block
    assert(box.evidence == privateKey.publicImage.generateEvidence)

    // generate block message (block with empty signature) to be signed
    val block = Block(parentId, timestamp, box, privateKey.publicImage, SignatureCurve25519.empty, txs, version)

    // generate signature from the block message and private key
    val signature = privateKey.sign(block.messageToSign)

    // return a valid block with the signature attached
    block.copy(signature = signature)
  }



  implicit val jsonEncoder: Encoder[Block] = { b: Block â‡’
    val (header, body) = b.toComponents
    Map(
      "id" -> b.id.toString.asJson,
      "parentId" -> b.parentId.toString.asJson,
      "timestamp" -> b.timestamp.asJson,
      "generatorBox" -> b.forgerBox.asJson,
      "publicKey" -> b.publicKey.asJson,
      "signature" -> b.signature.asJson,
      "txs" -> b.transactions.asJson,
      "bloomFilter" -> b.bloomFilter.asJson,
      "version" -> b.version.asJson,
      "blockSize" -> b.serializer.toBytes(b).length.asJson
    ).asJson
  }

  implicit val jsonDecoder: Decoder[Block] = (c: HCursor) =>
    for {
      parentId <- c.downField("parentId").as[ModifierId]
      timestamp <- c.downField("timestamp").as[Timestamp]
      generatorBox <- c.downField("generatorBox").as[ArbitBox]
      publicKey <- c.downField("publicKey").as[PublicKeyPropositionCurve25519]
      signature <- c.downField("signature").as[SignatureCurve25519]
      txsSeq <- c.downField("txs").as[Seq[Transaction.TX]]
      version <- c.downField("version").as[Byte]
    } yield {
      Block(parentId, timestamp, generatorBox, publicKey, signature, txsSeq, version)
    }
}
