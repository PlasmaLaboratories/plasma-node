package co.topl.attestation

import co.topl.utils.NodeGenerators
import org.scalatest.matchers.should.Matchers
import org.scalatest.propspec.AnyPropSpec
import org.scalatestplus.scalacheck.ScalaCheckDrivenPropertyChecks

class KeySpec extends AnyPropSpec with ScalaCheckDrivenPropertyChecks with NodeGenerators with Matchers {

  var password: String = _
  var messageByte: Array[Byte] = _

  var address: Address = _

  override def beforeAll(): Unit = {
    super.beforeAll()

    password = sampleUntilNonEmpty(stringGen)
    messageByte = sampleUntilNonEmpty(nonEmptyBytesGen)

    import org.scalatest.TryValues._

    address = keyRingCurve25519.DiskOps.generateKeyFile(password).success.value
  }

  property("The randomly generated address from generateKeyFile should exist in keyRing") {
    keyRingCurve25519.addresses.contains(address) shouldBe true
  }

  property("Once we lock the generated address, it will be removed from the secrets set in the keyRing") {
    keyRingCurve25519.removeFromKeyring(address)

    /** There will be a warning for locking again if a key is already locked */
    keyRingCurve25519.removeFromKeyring(address)

    keyRingCurve25519.addresses.contains(address) shouldBe false
  }

  property("Once unlocked, the address will be accessible from the keyRing again") {
    keyRingCurve25519.DiskOps.unlockKeyFile(address.toString, password)

    /** There will be a warning for unlocking again if a key is already unlocked */
    keyRingCurve25519.DiskOps.unlockKeyFile(address.toString, password)

    keyRingCurve25519.addresses.contains(address) shouldBe true
  }

  property("LookupPublickKey should return the correct public key to the address") {
    keyRingCurve25519.lookupPublicKey(address).get.address shouldEqual address
  }

  property("The proof generated by signing the message Bytes with address should be valid") {
    val proof = keyRingCurve25519.signWithAddress(address)(messageByte).get
    val prop = keyRingCurve25519.lookupPublicKey(address).get

    proof.isValid(prop, messageByte) shouldBe true
  }

  property("Trying to sign a message with an address not on the keyRing will fail") {
    val randAddr: Address = addressCurve25519Gen.sample.get
    val error = intercept[Exception](keyRingCurve25519.signWithAddress(randAddr)(messageByte))
    error.getMessage shouldEqual "Unable to find secret for the given address"
  }

  property("The proof from signing with an address should only be valid for the corresponding proposition") {
    val prop = keyRingCurve25519.lookupPublicKey(address).get

    val newAddr: Address = keyRingCurve25519.DiskOps.generateKeyFile(stringGen.sample.get).get
    val newProp = keyRingCurve25519.lookupPublicKey(newAddr).get
    val newProof = keyRingCurve25519.signWithAddress(newAddr)(messageByte).get

    newProof.isValid(prop, messageByte) shouldBe false
    newProof.isValid(newProp, messageByte) shouldBe true
  }

  //TODO: Jing - test importPhrase
}
