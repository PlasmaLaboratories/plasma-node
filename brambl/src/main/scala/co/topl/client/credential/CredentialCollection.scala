package co.topl.client.credential

import cats.Functor
import cats.data.Chain
import cats.implicits._
import co.topl.crypto.mnemonic.Bip32Indexes
import co.topl.crypto.signing.ExtendedEd25519
import co.topl.models._
import co.topl.typeclasses.implicits._

/**
 * Represents a "grouping" of credentials.  In all cases, a CredentialCollection is strictly typed to its Proposition type.
 * @tparam Prop The type of proposition generated by a credential in this collection
 */
sealed abstract class CredentialCollection[Prop <: Proposition] {
  def name: String
}

object CredentialCollection {

  /**
   * Load a credential collection by name from a CredentialIO instance
   */
  def load[F[_]](name: String)(implicit credentialIO: CredentialIO[F]): F[Option[CredentialCollection[_]]] =
    ???
}

/**
 * Represents a hierarchical credential collection derived from some root key
 *
 * HD keys
 * M / 1852' / 7091' / 0' (Account) / Role (External = 0, Internal = 1, ??? = N) / Index
 * NOTE: Keyfile must include Topl vs. Account
 */
sealed abstract class HierarchicalCredentialCollection
    extends CredentialCollection[Propositions.Knowledge.ExtendedEd25519]

/**
 * An HD credential collection such that the root is a Topl root
 * i.e. `M / 1852' / 7091'`
 */
case class ToplCredentialTree(name: String, rootKey: SecretKeys.ExtendedEd25519)
    extends HierarchicalCredentialCollection {

  /**
   * Retrieve the credential sub-tree corresponding to the account at the given index
   */
  def account(idx: Bip32Indexes.HardenedIndex): AccountCredentialTree =
    AccountCredentialTree(name, ExtendedEd25519.precomputed().deriveSecret(rootKey, idx))

  def /(idx: Bip32Indexes.HardenedIndex): AccountCredentialTree = account(idx)

}

object ToplCredentialTree {

  /**
   * Initialize and save a new ToplCredentialTree from some root key
   */
  def create[F[_]](name: String, rootKey: SecretKeys.ExtendedEd25519)(implicit
    credentialIO:        CredentialIO[F]
  ): F[ToplCredentialTree] =
    ???
}

/**
 * An HD credential collection such that the root is an Account _within_ a Topl root
 * i.e. `M / 1852' / 7091' / 0'`
 */
case class AccountCredentialTree(name: String, accountSK: SecretKeys.ExtendedEd25519)
    extends HierarchicalCredentialCollection {

  def role(roleIndex: Bip32Indexes.SoftIndex): RoleCredentialList = {
    val extendedEd25519 = ExtendedEd25519.precomputed()
    val roleSk = extendedEd25519.deriveSecret(accountSK, roleIndex)

    RoleCredentialList(roleSk)
  }

  def /(idx: Bip32Indexes.SoftIndex): RoleCredentialList = role(idx)

}

/**
 * An indexed collection of Credentials such that the root is a Role secret key
 */
case class RoleCredentialList(roleSK: SecretKeys.ExtendedEd25519) {

  def credential(index: Bip32Indexes.SoftIndex): Credential[Propositions.Knowledge.ExtendedEd25519] = {
    val extendedEd25519 = ExtendedEd25519.precomputed()
    val indexSk = extendedEd25519.deriveSecret(roleSK, index)
    Credential(indexSk)
  }

  def /(idx: Bip32Indexes.SoftIndex): Credential[Propositions.Knowledge.ExtendedEd25519] = credential(idx)

}

object AccountCredentialTree {

  /**
   * Initialize and save a new AccountCredentialTree from some root key
   */
  def create[F[_]](name: String, rootKey: SecretKeys.ExtendedEd25519)(implicit
    credentialIO:        CredentialIO[F]
  ): F[AccountCredentialTree] =
    ???
}

/**
 * A set of unrelated keys of the same type
 */
case class CredentialSet[Prop <: Proposition](name: String, credentials: Set[Credential[Prop]])
    extends CredentialCollection[Prop] {

  /**
   * Persist a credential and include it in this Set
   */
  def withCredential[F[_]: Functor](
    credential:            Credential[Prop]
  )(implicit credentialIO: CredentialIO[F]): F[CredentialSet[Prop]] =
    credentialIO
      .write(name, credential)
      .map(_ => copy(credentials = credentials + credential))

  /**
   * Delete a credential and remove it from this Set
   */
  def withoutCredential[F[_]: Functor](
    credential:            Credential[Prop]
  )(implicit credentialIO: CredentialIO[F]): F[CredentialSet[Prop]] =
    credentialIO
      .delete(name, credential.address)
      .map(_ => copy(credentials = credentials - credential))
}

object CredentialSet {

  /**
   * Create an empty credential set
   */
  def empty[Prf <: Proof, Prop <: Proposition](name: String): CredentialSet[Prop] =
    CredentialSet(name, Set.empty)
}

/**
 * Assumes a directory structure of
 *
 * /walletRoot/credentials/_credentialCollectionName_/_address_.json
 */
trait CredentialIO[F[_]] {
  def write(credentialSetName: String, credential: Credential[_]): F[Unit]

  def delete(credentialSetName: String, address: DionAddress): F[Unit]

  def read[Prf <: Proof, Prop <: Proposition](
    credentialSetName: String,
    address:           DionAddress
  ): F[Option[CredentialCollection[Prop]]]

  def listCollectionNames: F[Chain[String]]
}
