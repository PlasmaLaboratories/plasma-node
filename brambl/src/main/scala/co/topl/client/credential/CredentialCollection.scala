package co.topl.client.credential

import cats.data.OptionT
import cats.implicits._
import cats.{Applicative, Functor}
import co.topl.crypto.mnemonic.Bip32Indexes
import co.topl.crypto.signing.{ExtendedEd25519, Password}
import co.topl.models._
import co.topl.models.utility.HasLength.instances.bytesLength
import co.topl.models.utility.Sized
import co.topl.typeclasses.implicits._
import com.google.common.primitives.Longs

/**
 * Represents a "grouping" of credentials.  In all cases, a CredentialCollection is strictly typed to its Proposition type.
 * @tparam Prop The type of proposition generated by a credential in this collection
 */
sealed abstract class CredentialCollection[Prop <: Proposition] {
  def name: String
}

/**
 * Represents a hierarchical credential collection derived from some root key
 *
 * HD keys
 * M / 1852' / 7091' / 0' (Account) / Role (External = 0, Internal = 1, ??? = N) / Index
 * NOTE: Keyfile must include Topl vs. Account
 */
sealed abstract class HierarchicalCredentialCollection
    extends CredentialCollection[Propositions.Knowledge.ExtendedEd25519]

/**
 * An HD credential collection such that the root is a Topl root
 * i.e. `M / 1852' / 7091'`
 */
case class ToplCredentialTree(name: String, rootKey: SecretKeys.ExtendedEd25519)
    extends HierarchicalCredentialCollection {

  /**
   * Retrieve the credential sub-tree corresponding to the account at the given index
   */
  def account(idx: Bip32Indexes.HardenedIndex): AccountCredentialTree =
    AccountCredentialTree(name, ExtendedEd25519.precomputed().deriveSecret(rootKey, idx))

  def /(idx: Bip32Indexes.HardenedIndex): AccountCredentialTree = account(idx)

}

object ToplCredentialTree {

  /**
   * Initialize and save a new ToplCredentialTree from some root key
   */
  def create[F[_]: Applicative](name: String, roleSk: SecretKeys.ExtendedEd25519, password: Password)(implicit
    credentialIO:                     CredentialIO[F],
    networkPrefix:                    NetworkPrefix
  ): F[ToplCredentialTree] = {
    val rawBytes =
      roleSk.leftKey.data ++
      roleSk.rightKey.data ++
      roleSk.chainCode.data ++
      Bytes(Longs.toByteArray(1852)) ++
      Bytes(Longs.toByteArray(7091)) ++
      Bytes(Longs.toByteArray(-1)) ++
      Bytes(Longs.toByteArray(-1))
    credentialIO
      .write(name, roleSk.dionAddress.typedEvidence.evidence, KeyFile.Metadata.ExtendedEd25519, rawBytes, password)
      .as(ToplCredentialTree(name, roleSk))
  }

}

/**
 * An HD credential collection such that the root is an Account _within_ a Topl root
 * i.e. `M / 1852' / 7091' / 0'`
 */
case class AccountCredentialTree(name: String, accountSK: SecretKeys.ExtendedEd25519)
    extends HierarchicalCredentialCollection {

  def role(roleIndex: Bip32Indexes.SoftIndex): RoleCredentialList = {
    val extendedEd25519 = ExtendedEd25519.precomputed()
    val roleSk = extendedEd25519.deriveSecret(accountSK, roleIndex)

    RoleCredentialList(roleSk)
  }

  def /(idx: Bip32Indexes.SoftIndex): RoleCredentialList = role(idx)

}

object AccountCredentialTree {

  /**
   * Initialize and save a new AccountCredentialTree from some root key
   */
  def create[F[_]: Applicative](name: String, accountSK: SecretKeys.ExtendedEd25519, account: Long, password: Password)(
    implicit
    credentialIO:  CredentialIO[F],
    networkPrefix: NetworkPrefix
  ): F[AccountCredentialTree] = {
    val rawBytes =
      accountSK.leftKey.data ++
      accountSK.rightKey.data ++
      accountSK.chainCode.data ++
      Bytes(Longs.toByteArray(1852)) ++
      Bytes(Longs.toByteArray(7091)) ++
      Bytes(Longs.toByteArray(account)) ++
      Bytes(Longs.toByteArray(-1))
    credentialIO
      .write(name, accountSK.dionAddress.typedEvidence.evidence, KeyFile.Metadata.ExtendedEd25519, rawBytes, password)
      .as(AccountCredentialTree(name, accountSK))
  }
}

/**
 * An indexed collection of Credentials such that the root is a Role secret key
 */
case class RoleCredentialList(roleSK: SecretKeys.ExtendedEd25519) {

  def credential(
    index:                  Bip32Indexes.SoftIndex
  )(implicit networkPrefix: NetworkPrefix): Credential[Propositions.Knowledge.ExtendedEd25519] = {
    val extendedEd25519 = ExtendedEd25519.precomputed()
    val indexSk = extendedEd25519.deriveSecret(roleSK, index)
    Credential(indexSk)
  }

  def /(idx:       Bip32Indexes.SoftIndex)(implicit
    networkPrefix: NetworkPrefix
  ): Credential[Propositions.Knowledge.ExtendedEd25519] = credential(idx)

}

/**
 * A set of unrelated keys of the same type
 */
case class CredentialSet[Prop <: Proposition](name: String, credentials: Map[Evidence, Credential[Prop]])
    extends CredentialCollection[Prop] {

  def unlock[F[_]: Functor](evidence: Evidence, password: Password)(implicit
    credentialIO:                     CredentialIO[F],
    networkPrefix:                    NetworkPrefix
  ): F[Option[Credential[Prop]]] =
    OptionT(credentialIO.unlock(name, evidence, password)).map { case (bytes, metadata) =>
      metadata.keyType match {
        case KeyFile.Metadata.Curve25519 =>
          Credential(SecretKeys.Curve25519(Sized.strictUnsafe(bytes))).asInstanceOf[Credential[Prop]]
        case KeyFile.Metadata.Ed25519 =>
          Credential(SecretKeys.Ed25519(Sized.strictUnsafe(bytes))).asInstanceOf[Credential[Prop]]
        case KeyFile.Metadata.ExtendedEd25519 =>
          Credential(
            SecretKeys.ExtendedEd25519(
              Sized.strictUnsafe(bytes.slice(0, 32)),
              Sized.strictUnsafe(bytes.slice(32, 64)),
              Sized.strictUnsafe(bytes.slice(64, 96))
            )
          ).asInstanceOf[Credential[Prop]]
      }
    }.value

  def evidences[F[_]](implicit credentialIO: CredentialIO[F]): F[Set[Evidence]] =
    credentialIO.listEvidence(name)

  def persistAndInclude[F[_]: Functor](
    credential:            Credential[Prop],
    credentialBytes:       Bytes,
    keyType:               KeyFile.Metadata.KeyType,
    password:              Password
  )(implicit credentialIO: CredentialIO[F]): F[CredentialSet[Prop]] =
    credentialIO
      .write(name, credential.address.typedEvidence.evidence, keyType, credentialBytes, password)
      .as(copy(credentials = credentials.updated(credential.address.typedEvidence.evidence, credential)))

  /**
   * Delete a credential and remove it from this Set
   */
  def withoutCredential[F[_]: Functor](
    evidence:              Evidence
  )(implicit credentialIO: CredentialIO[F]): F[CredentialSet[Prop]] =
    credentialIO
      .delete(name, evidence)
      .as(copy(credentials = credentials.removed(evidence)))
}

object CredentialSet {

  /**
   * Create an empty credential set
   */
  def apply[Prop <: Proposition](name: String): CredentialSet[Prop] =
    CredentialSet(name, Map.empty)
}
