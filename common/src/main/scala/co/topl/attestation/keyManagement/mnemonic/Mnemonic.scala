package co.topl.attestation.keyManagement.mnemonic

import cats.implicits._
import co.topl.attestation.keyManagement.mnemonic.Language.WordList
import co.topl.crypto.hash.sha256

import java.util.UUID

/**
 * A mnemonic represents a set of entropy that can be used to derive a private key given an optional password.
 * This implementation follows a combination of BIP-0039 and SLIP-0023.
 * https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
 * https://github.com/satoshilabs/slips/blob/master/slip-0023.md
 */
object Mnemonic {

  /**
   * The words of the mnemonic phrase
   */
  type Phrase = IndexedSeq[String]

  /**
   * The entropy generated from a mnemonic phrase
   */
  type Entropy = Array[Byte]

  /*
   * ENT = entropy
   * CS (checksum) = ENT / 32
   * MS (mnemonic size) = (ENT + CS) / 11
   *
   * |  ENT  | CS | ENT+CS |  MS  |
   * +-------+----+--------+------+
   * |  128  |  4 |   132  |  12  |
   * |  160  |  5 |   165  |  15  |
   * |  192  |  6 |   198  |  18  |
   * |  224  |  7 |   231  |  21  |
   * |  256  |  8 |   264  |  24  |
   *
   */

  /**
   * Mnemonic size is an enum with additional parameters for calculating checksum and entropy lengths.
   *
   * @param wordLength the size of the mnemonic
   */
  sealed abstract class MnemonicSize(val wordLength: Int) {
    val checksumLength: Int = wordLength / 3
    val entropyLength: Int = 32 * checksumLength
  }

  case object Mnemonic12 extends MnemonicSize(12)
  case object Mnemonic15 extends MnemonicSize(15)
  case object Mnemonic18 extends MnemonicSize(18)
  case object Mnemonic21 extends MnemonicSize(21)
  case object Mnemonic24 extends MnemonicSize(24)

  sealed trait CreateMnemonicFailure
  case class InvalidWordLength() extends CreateMnemonicFailure
  case class InvalidWords() extends CreateMnemonicFailure
  case class BadWordList(error: WordListFailure) extends CreateMnemonicFailure
  case class InvalidChecksum() extends CreateMnemonicFailure
  case class InvalidLanguageHash() extends CreateMnemonicFailure

  /**
   * Derives a value `T` from a mnemonic if it is valid.
   *
   * @param phrase the mnemonic phrase
   * @param size the size of the mnemonic phrase
   * @param language the language to pull the word list for
   * @tparam T the value to instantiate from the mnemonic
   * @return either a `CreateMnemonicFailure` or a `T` value
   */
  def derive[T: FromMnemonic](
    phrase:   String,
    size:     MnemonicSize,
    language: Language
  ): Either[CreateMnemonicFailure, T] =
    for {
      wordList <- language.words.leftMap(BadWordList)
      // split on whitespace
      phraseWords = phrase.toLowerCase.split("\\s+").map(_.trim).toIndexedSeq
      validWordLength <- validateWordLength(phraseWords, size.wordLength)
      validWords      <- validateWords(validWordLength, wordList)
      validChecksum   <- validateChecksum(validWords, wordList, size)
    } yield deriveFromValidatedPhrase(validChecksum, wordList, size)

  /**
   * Derives a value `T` from a mnemonic generated by the given UUID in the given language.
   *
   * @param uuid     the UUID to convert into entropy
   * @param language the language of the mnemonic
   * @tparam T the type of value to create from the mnemonic
   * @return either a `CreateMnemonicFailure` or a `T` value
   */
  def derive[T: FromMnemonic](uuid: UUID, language: Language): Either[CreateMnemonicFailure, T] =
    derive(
      uuid.toString.filterNot("-".toSet).grouped(2).map(Integer.parseInt(_, 16).toByte).toArray,
      Mnemonic12,
      language
    )

  /**
   * Derives a value `T` from a mnemonic generated by a collection of entropy.
   *
   * @param entropy the entropy collection
   * @param size the expected size of the entropy
   * @param language the language to create the mnemonic in
   * @tparam T the resulting value created from the mnemonic
   * @return either a `CreateMnemonicFailure` or a valid mnemonic of the given size
   */
  def derive[T: FromMnemonic](
    entropy:  Entropy,
    size:     MnemonicSize,
    language: Language
  ): Either[CreateMnemonicFailure, T] =
    for {
      validEntropy <- Either.cond(entropy.length * byteLen == size.entropyLength, entropy, InvalidWordLength())
      wordList     <- language.words.leftMap(BadWordList)
      phraseBinary = validEntropy.map(toBinaryString).mkString("")
      entropyHash = sha256.hash(validEntropy).value.map(toBinaryString)
      phrase = phraseFromBinaryString(phraseBinary, entropyHash, size, wordList)
    } yield deriveFromValidatedPhrase(phrase, wordList, size)

  /**
   * Creates a mnemonic phrase from the given string of binary numbers (0,1) and binary hashes of the original entropy
   * bytes.
   *
   * @param phraseBinary the binary string to convert to a mnemonic
   * @param entropyHashBytes the hashes of the original entropy bytes
   * @param size         the size of the mnemonic
   * @param wordList     the word list to create the mnemonic from
   * @return a mnemonic phrase
   */
  private def phraseFromBinaryString(
    phraseBinary:     String,
    entropyHashBytes: Array[String],
    size:             MnemonicSize,
    wordList:         WordList
  ): Phrase =
    (phraseBinary + entropyHashBytes(0).slice(0, size.checksumLength))
      .grouped(indexLen)
      .toArray
      .map(Integer.parseInt(_, 2))
      .map(wordList(_))

  /**
   * Validates that the length of the given mnemonic phrase matches the expected length.
   * @param phrase the mnemonic phrase
   * @param expected the expected length of the phrase
   * @return a `CreateMnemonicFailure` if invalid or the validated phrase
   */
  private def validateWordLength(
    phrase:   Phrase,
    expected: Int
  ): Either[CreateMnemonicFailure, IndexedSeq[String]] =
    Either.cond(
      phrase.length == expected,
      phrase,
      InvalidWordLength()
    )

  /**
   * Validates that the given set of words exists in the given word list.
   * @param phrase the mnemonic phrase to validate
   * @param expected the word list to check against
   * @return a `CreateMnemonicFailure` if invalid or the validated phrase
   */
  private def validateWords(
    phrase:   Phrase,
    expected: WordList
  ): Either[CreateMnemonicFailure, IndexedSeq[String]] =
    Either.cond(
      phrase.forall(expected.contains),
      phrase,
      InvalidWords()
    )

  /**
   * Validates the checksum of the given mnemonic phrase.
   * @param phrase the mnemonic phrase
   * @param wordList the BIP-0039 word list
   * @param size the expected mnemonic size
   * @return a `CreateMnemonicFailure` if invalid or the validated phrase
   */
  private def validateChecksum(
    phrase:   Phrase,
    wordList: WordList,
    size:     MnemonicSize
  ): Either[CreateMnemonicFailure, Phrase] = {
    // the phrase converted to binary with each word being 11 bits
    val phraseBinary: String = phrase.map(wordList.indexOf(_)).map(toBinaryStringWith11Bits).mkString

    val entropyHash: List[String] =
      sha256
        .hash(
          // get the first `entropyLength` number of bits and hash the resulting byte array
          phraseBinary
            .slice(0, size.entropyLength)
            .grouped(byteLen)
            .toArray
            .map(Integer.parseInt(_, 2).toByte)
        )
        .value
        .map(toBinaryString)
        .toList

    Either.cond(
      // checksum section of phrase should be equal to hash of the entropy section
      phraseBinary.substring(size.entropyLength) == entropyHash.head.slice(0, size.checksumLength),
      phrase,
      InvalidChecksum()
    )
  }

  /**
   * @param validatedPhrase the validated mnemonic phrase
   * @param wordList the word list to use
   * @param size te size of the mnemonic
   * @return a `Mnemonic` value that can be used to derive an extended private key
   */
  private def deriveFromValidatedPhrase[T: FromMnemonic](
    validatedPhrase: Phrase,
    wordList:        WordList,
    size:            MnemonicSize
  ): T =
    FromMnemonic[T].deriveFrom(
      entropyFromValidatedPhrase(validatedPhrase, wordList, size),
      validatedPhrase
    )

  /**
   * Creates a byte array of entropy from a valid mnemonic phrase.
   *
   * The steps of this function are a reversal of the steps documented at
   * https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
   * under the `Generating the mnemonic` section.
   *
   * @param phrase the mnemonic phrase
   * @param wordList the word list
   * @param size the mnemonic size
   * @return the entropy representing the mnemonic phrase
   */
  private def entropyFromValidatedPhrase(
    phrase:   Phrase,
    wordList: WordList,
    size:     MnemonicSize
  ): Entropy =
    phrase
      .map(wordList.indexOf(_))
      // map indices to 11 bit representations
      .map(toBinaryStringWith11Bits)
      .mkString
      .slice(0, size.entropyLength)
      // group into bytes
      .grouped(byteLen)
      .map(Integer.parseInt(_, 2))
      .map(_.toByte)
      .toArray
}
